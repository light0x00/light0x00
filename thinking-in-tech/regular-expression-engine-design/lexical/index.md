[返回目录](../index.md)

# 词法分析

词法分析的任务是把输入序列分割为词素单元.

在自然语言中, 以英语为例, 构成句子的最小单元,可以是单词、短语, 这些最小单元称作 **词素(lexeme)** . 词素具有属性, 比如动词、名词、副词、形容词等, 这些属性决定了语法层面, 其在句子里可充当的成分.

对于程序语言, 个人的感受是, 对词素并没有一个固定的边界定义, 如果词法分析阶段做的事少一点, 那么语法分析阶段做的事就要多一点, 考虑到语法分析要远比词法分析复杂, 所以后者应当为前者服务, 以尽可能减轻语法分析的复杂度. 因此,我一般先设计文法(也称语法), 在过程中考虑需要有哪些类型的词素.

这里我们先确定两种基本的词素:

1. 匹配字符, 即需要用于匹配的字符, 如单个字符, `\` 引导的转义字符 ,`\u` 引导的 Unicode code point
2. 控制字符, 不匹配, 具有特殊语义的字符 , 如 `|` , `?` , `+` ,`*` , `(` , `)`

## 词素的数据类型

直觉上会想到用 `char` 表示词素, 在很多语言中, `char` 类型是 16 bit, 采用 UTF-16 编码 (比如 JAVA 和 C#), 对于占用 2 个 code unit 的 unicode 字符需要占用 2 个 char, 所以一个超过 `0XFFFF` 的 Unicode 字符会被分割为两个词素. 这对于单点匹配没有什么问题,但是,对于范围匹配如 `[😀	-🙏]` ,对应的 Unicode code point 范围是 `[\u{1F600}-\u{1F64F}]`,不可能把边界 `1F600` 和 `1F64F` 分别拆成两个 char .

如果用 `String` 表示,可以满足功能实现,但是对象类型会造成较大的空间浪费.

如果用 `int` 表示,那么刚好 32 bit,可以直接存 Unicode code point,空间占用合理,也很方便程序统一处理.

## 关于 EOF

由于我们采用基础类型 `int ` 存储词素, 当读完时返回 `null` 是不行的. 好在, Unicode code point 的范围是  `0x0000 0000` ~ `0x0010 FFFF` [^1] , 所以可以采用一个超出该范围的特殊值表示 EOF.

[^1]: [Proposal to restrict the range of code positions to the values up to U-0010FFFF](http://www.unicode.org/L2/L2000/00079-n2175.htm)

## 词法分析的编码实现

在编码实现上, 一个经验指导是, 使用策略模式独立出不同类型的词素的分词逻辑, 以对象组合的方式组装出词法分析器. 一个词法分析器由多个分词策略组成, 这些分词策略具有不同的优先级, 可采用一个排序树的结构来存放.